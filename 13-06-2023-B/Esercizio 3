**********************************TRACCIA****************************
Implementare la funzione:
TipoAlbero espandiAlbero(TipoAbero a, int k);
che dato in ingresso un albero binario a e un intero k, restituisce un nuovo albero che ha la stessa struttura di base dell'albero input,
e che per ogni nodo foglia genera un nuovo figlio (a sinistra) il cui valore i è pari al valore della foglia n se k è minore uguale alla media del percorso fino alla foglia (foglia esclusa), 
altrimenti è pari a - il valore della foglia n.
NB: Per l'albero vuoto non va effettuata nessuna modifica. Per la radice, considerare 0 come somma degli antenati.

ESEMPIO:
Dato l'albero:

      3 		
    /   \
   3     4		
  / \      \ 
 1   1      3		
/
8

con k = 3
Abbiamo 3 nodi foglia: 8, 1, e 3.
La media del percorso fino ad 8 è 2,33 che è minore di k, quindi avrà un figlio con valore pari a -8.
La media del percorso fino ad 1 è 3 che è uguale a k, quindi avrà un figlio con valore pari a -1.
La media del percorso fino a 3 è 3,5 che è maggiore di k, quindi avrà un figlio con valore pari a 3.

L’albero ritornato sarà pertanto il seguente.
         3 		
       /   \
     3      4		
    / \       \ 
   1   1        3		
  /    /        /
 8    -1       3
              /
            -8

*****************************IMPLEMENTAZIONE**********************************
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "aux.h"


bool foglia(TipoAlbero a){
  return (estVuoto(sinistro(a)) && estVuoto(destro(a)));
}

TipoAlbero espandi_aux(TipoAlbero a,float k, float somma, float ind){
  if(estVuoto(a)) return albBinVuoto();
  if(foglia(a) && k<(somma/ind)){
    return creaAlbBin(radice(a),creaAlbBin(radice(a),albBinVuoto(),albBinVuoto()),albBinVuoto());
  }
  if(foglia(a) && k>=(somma/ind-1)){
    return creaAlbBin(radice(a),creaAlbBin(-(radice(a)),albBinVuoto(),albBinVuoto()),albBinVuoto());
  }
  somma+=radice(a); // se non mi trovo su una foglia aggiorno il valore di somma
  printf("%f \n",somma);
  ind++; //aggiorno il numero di nodi incontrati 
  return creaAlbBin(radice(a),espandi_aux(sinistro(a),k,somma,ind),espandi_aux(destro(a),k,somma,ind)); //chiamate ricorsive a sinistra e destra;
}

//FUNZIONE PRINCIPALE
TipoAlbero espandiAlbero(TipoAlbero a, int k) {
  if(estVuoto(a)) return albBinVuoto();
  if(foglia(a)) return creaAlbBin(radice(a),creaAlbBin(-radice(a),albBinVuoto(),albBinVuoto()),albBinVuoto());
  return espandi_aux(a,k,0,0);
}

